# A. Deploying a web app to Kubernetes with SSL using Let's Encrypt via cert-manager and nginx-ingress

### A1. Deploy nginx-ingress
```sh
helm install stable/nginx-ingress --namespace kube-system --name ingress --set rbac.create=true
```


### A2. Deploy cert-manager

###### Download from: https://github.com/jetstack/cert-manager/releases/tag/v0.15.2
Get the latest version if needed in the future
- CRD
- Cert-manager deployment
```sh
kubectl apply -f cert-manager-deployment/cert-manager.crds.yaml
kubectl apply -f cert-manager-deployment/cert-manager.yaml
```

### A3. Deploy Application with ingress resources
```sh
kubectl apply -f application/app-deployment.yaml
kubectl apply -f application/cert-issuers.yaml
```

### A4. Register free domain app.baohuyh.tk
Visit below website and point app.baohuynh.tk -> LoadBalance IP in GKE
```sh
https://my.freenom.com/clientarea.php?action=domaindetails&id=1095616933
```

### A5. Checking Flow for cert-manager
- ###### Create ClusterIssuer / Issuer (CRD from cert-manager)
  
  Act as bridge between ACME server <--> client in the process of getting SSL certificate
   ```sh
   apiVersion: cert-manager.io/v1alpha2
   kind: ClusterIssuer
   metadata:
     name: letsencrypt-prod
   spec:
     acme:
       server: https://acme-v02.api.letsencrypt.org/directory
       email: huynhthaibao07@gmail.com
       privateKeySecretRef:
         name: letsencrypt-prod
       #http01: {}
       solvers:
       - http01:
           ingress:
             class: nginx
   ```   
- "Cluster-issuer" then **AUTOMATICALLY** generate "certificate", which indicate the status of getting SSL cert from letsencrypt server
- NOTE: real SSL is stored in secret "foobar" (describe the cerificate to get the Message)

- ###### "Ingress" consume the SSL cert for domain (store in secret foobar)

  ```sh
  ...................
    tls:
  - hosts:
    - app.baohuynh.tk
    secretName: foobar
  ```


### A6. Reference
- https://gist.github.com/snormore/c7c2935d746531ed0d75064a6ad6058e
- https://itnext.io/automated-tls-with-cert-manager-and-letsencrypt-for-kubernetes-7daaa5e0cae4

### A7. Cert-manager workflow for Public Domain
![alt text](https://github.com/baohuynh09/letsencrypt-cert-manager/blob/master/images/cert-manager-workflow-public-domain-1.png?raw=true)

---

# B. Deploy self-signed CA and using cert-manager for domain with self-signed SSL (HTTPS local development)

### B1. Understanding Terms:
- **private/internal domain**: k8s-dashboard.baohuynh.tk
- **self-signed CA**: normally, CA is managed by an official company outhere (like globalSign, ACME - LetsEncrypt). But when using with "private domain", it doesn't recognized => could not offer self-signed SSL.
- **self-signed SSL**: SSL certs generated by self-signed CA (private)

### B2. Components to Deploy:
- ###### B2.1 Create self-signed CA using mkcert
```sh
# Reference: https://github.com/FiloSottile/mkcert
$ ssh root@<some_machine>
$ mkdir /root/self-signed-ca
$ CAROOT=/root/self-signed-ca mkcert -install
```

- ###### B2.2 Create K8S Secret that stores above self-signed CA
```sh
kubectl -n <some_namespace> create secret tls self-signed-ca --key=<some_folder>/rootCA-key.pem --cert=<some_folder>/rootCA.pem
```

- ###### B2.3 Create Issuer CRD that creates self-signed-SSL & store in another secrets

Input of Issuer: self-signed-ca (secret)


Output of Issuer: self-signel-ssl-<something> (secret)

```sh
apiVersion: cert-manager.io/v1alpha2
kind: Issuer
metadata:
    name: self-signed-ca-issuer
    namespace: devops
spec:
  ca:
    secretName: self-signed-ca
```

- ###### B2.4 Create Serivce Ingress with *Annotations*
Question: How secret *self-signed-ssl-k8s-dashboard* is created

Answer: Be applying **annotations**, Issuer (self-signed-ca-issuer) knows to create an self-signed-SSL cert pair & put them into Secret (self-signed-ssl-k8s-dashboard)
```sh
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: k8s-dashboard
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/issuer: self-signed-ca-issuer
spec:
  tls:
  - hosts:
    - k8s-dashboard.baohuynh.internal
    secretName: self-signed-ssl-k8s-dashboard
  rules:
  - host: k8s-dashboard.baohuynh.internal
    http:
      paths:
      - path: "/"
        backend:
          serviceName: k8s-dashboard
          servicePort: http
```

- ###### B2.5 Reference
https://itnext.io/deploying-tls-certificates-for-local-development-and-production-using-kubernetes-cert-manager-9ab46abdd569


- ###### B2.6 Cert-manager workflow for private Domain
![alt text](https://github.com/baohuynh09/letsencrypt-cert-manager/blob/master/images/cert-manager-workflow-private-domain.png?raw=true)
